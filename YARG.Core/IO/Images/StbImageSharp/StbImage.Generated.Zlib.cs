// Generated by Sichem at 9/16/2024 9:09:30 AM

using Hebron.Runtime;
using System.Runtime.InteropServices;
using YARG.Core.IO;

namespace StbImageSharp
{
	unsafe partial class StbImage
	{
		public static readonly byte[] stbi__zdefault_distance =
			{ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };

		public static readonly byte[] stbi__zdefault_length =
		{
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
			9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8
		};

		public static readonly int[] stbi__zdist_base =
		{
			1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097,
			6145, 8193, 12289, 16385, 24577, 0, 0
		};

		public static readonly int[] stbi__zdist_extra =
			{ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0 };

		public static readonly int[] stbi__zlength_base =
		{
			3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195,
			227, 258, 0, 0
		};

		public static readonly int[] stbi__zlength_extra =
			{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };

		public static bool stbi_zlib_decode_malloc_guesssize_headerflag(sbyte* buffer, int len, int initial_size, int* outlen, int parse_header, out FixedArray<sbyte> result)
		{
			var a = new stbi__zbuf();
			using var p = FixedArray<sbyte>.Alloc(initial_size);
			a.zbuffer = (byte*)buffer;
			a.zbuffer_end = (byte*)buffer + len;
			if (stbi__do_zlib(&a, &p, initial_size, 1, parse_header))
			{
				if (outlen != null)
					*outlen = (int)(a.zout - p.Ptr);
                result = p.TransferOwnership();
				return true;
			}
            result = FixedArray<sbyte>.Null;
			return false;
		}

		public static bool stbi__zbuild_huffman(stbi__zhuffman* z, byte* sizelist, int num)
		{
			var i = 0;
			var k = 0;
			var code = 0;
			var next_code = stackalloc int[16];
			var sizes = stackalloc int[17];
			CRuntime.memset(sizes, 0, (ulong)(17 * sizeof(int)));
			CRuntime.memset(z->fast, 0, (ulong)(512 * sizeof(ushort)));
			for (i = 0; i < num; ++i)
				++sizes[sizelist[i]];

			sizes[0] = 0;
			for (i = 1; i < 16; ++i)
				if (sizes[i] > 1 << i)
					return false;

			code = 0;
			for (i = 1; i < 16; ++i)
			{
				next_code[i] = code;
				z->firstcode[i] = (ushort)code;
				z->firstsymbol[i] = (ushort)k;
				code = code + sizes[i];
				if (sizes[i] != 0)
					if (code - 1 >= 1 << i)
						return false;
				z->maxcode[i] = code << (16 - i);
				code <<= 1;
				k += sizes[i];
			}

			z->maxcode[16] = 0x10000;
			for (i = 0; i < num; ++i)
			{
				int s = sizelist[i];
				if (s != 0)
				{
					var c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
					var fastv = (ushort)((s << 9) | i);
					z->size[c] = (byte)s;
					z->value[c] = (ushort)i;
					if (s <= 9)
					{
						var j = stbi__bit_reverse(next_code[s], s);
						while (j < 1 << 9)
						{
							z->fast[j] = fastv;
							j += 1 << s;
						}
					}

					++next_code[s];
				}
			}

			return true;
		}

		public static int stbi__zeof(stbi__zbuf* z)
		{
			return z->zbuffer >= z->zbuffer_end ? 1 : 0;
		}

		public static byte stbi__zget8(stbi__zbuf* z)
		{
			return (byte)(stbi__zeof(z) != 0 ? 0 : *z->zbuffer++);
		}

		public static void stbi__fill_bits(stbi__zbuf* z)
		{
			do
			{
				if (z->code_buffer >= 1U << z->num_bits)
				{
					z->zbuffer = z->zbuffer_end;
					return;
				}

				z->code_buffer |= (uint)stbi__zget8(z) << z->num_bits;
				z->num_bits += 8;
			} while (z->num_bits <= 24);
		}

		public static uint stbi__zreceive(stbi__zbuf* z, int n)
		{
			uint k = 0;
			if (z->num_bits < n)
				stbi__fill_bits(z);
			k = (uint)(z->code_buffer & ((1 << n) - 1));
			z->code_buffer >>= n;
			z->num_bits -= n;
			return k;
		}

		public static int stbi__zhuffman_decode_slowpath(stbi__zbuf* a, stbi__zhuffman* z)
		{
			var b = 0;
			var s = 0;
			var k = 0;
			k = stbi__bit_reverse((int)a->code_buffer, 16);
			for (s = 9 + 1; ; ++s)
				if (k < z->maxcode[s])
					break;

			if (s >= 16)
				return -1;
			b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];
			if (b >= 288)
				return -1;
			if (z->size[b] != s)
				return -1;
			a->code_buffer >>= s;
			a->num_bits -= s;
			return z->value[b];
		}

		public static int stbi__zhuffman_decode(stbi__zbuf* a, stbi__zhuffman* z)
		{
			var b = 0;
			var s = 0;
			if (a->num_bits < 16)
			{
				if (stbi__zeof(a) != 0)
				{
					if (a->hit_zeof_once == 0)
					{
						a->hit_zeof_once = 1;
						a->num_bits += 16;
					}
					else
					{
						return -1;
					}
				}
				else
				{
					stbi__fill_bits(a);
				}
			}

			b = z->fast[a->code_buffer & ((1 << 9) - 1)];
			if (b != 0)
			{
				s = b >> 9;
				a->code_buffer >>= s;
				a->num_bits -= s;
				return b & 511;
			}

			return stbi__zhuffman_decode_slowpath(a, z);
		}

		public static bool stbi__zexpand(stbi__zbuf* z, sbyte* zout, int n)
		{
			uint cur = 0;
			uint limit = 0;
			uint old_limit = 0;
			z->zout = zout;
			if (z->z_expandable == 0)
				return false;
			cur = (uint)(z->zout - z->zout_start->Ptr);
			limit = old_limit = (uint)(z->zout_end - z->zout_start->Ptr);
			if (0xffffffff - cur < (uint)n)
				return false;
			while (cur + n > limit)
			{
				if (limit > 0xffffffff / 2)
					return false;
				limit *= 2;
			}

            z->zout_start->Resize((int)limit);
			z->zout = z->zout_start->Ptr + cur;
			z->zout_end = z->zout_start->Ptr + limit;
			return true;
		}

		public static bool stbi__parse_huffman_block(stbi__zbuf* a)
		{
			var zout = a->zout;
			for (; ; )
			{
				var z = stbi__zhuffman_decode(a, &a->z_length);
				if (z < 256)
				{
					if (z < 0)
						return false;
					if (zout >= a->zout_end)
					{
						if (!stbi__zexpand(a, zout, 1))
							return false;
						zout = a->zout;
					}

					*zout++ = (sbyte)z;
				}
				else
				{
					byte* p;
					var len = 0;
					var dist = 0;
					if (z == 256)
					{
						a->zout = zout;
						if (a->hit_zeof_once != 0 && a->num_bits < 16)
							return false;

						return true;
					}

					if (z >= 286)
						return false;
					z -= 257;
					len = stbi__zlength_base[z];
					if (stbi__zlength_extra[z] != 0)
						len += (int)stbi__zreceive(a, stbi__zlength_extra[z]);
					z = stbi__zhuffman_decode(a, &a->z_distance);
					if (z < 0 || z >= 30)
						return false;
					dist = stbi__zdist_base[z];
					if (stbi__zdist_extra[z] != 0)
						dist += (int)stbi__zreceive(a, stbi__zdist_extra[z]);
					if (zout - a->zout_start->Ptr < dist)
						return false;
					if (len > a->zout_end - zout)
					{
						if (!stbi__zexpand(a, zout, len))
							return false;
						zout = a->zout;
					}

					p = (byte*)(zout - dist);
					if (dist == 1)
					{
						var v = *p;
						if (len != 0)
							do
							{
								*zout++ = (sbyte)v;
							} while (--len != 0);
					}
					else
					{
						if (len != 0)
							do
							{
								*zout++ = (sbyte)*p++;
							} while (--len != 0);
					}
				}
			}
		}

		public static bool stbi__compute_huffman_codes(stbi__zbuf* a)
		{
			var z_codelength = new stbi__zhuffman();
			var lencodes = stackalloc byte[455];
			var codelength_sizes = stackalloc byte[19];
			var i = 0;
			var n = 0;
			var hlit = (int)(stbi__zreceive(a, 5) + 257);
			var hdist = (int)(stbi__zreceive(a, 5) + 1);
			var hclen = (int)(stbi__zreceive(a, 4) + 4);
			var ntot = hlit + hdist;
			CRuntime.memset(codelength_sizes, 0, (ulong)(19 * sizeof(byte)));
			for (i = 0; i < hclen; ++i)
			{
				var s = (int)stbi__zreceive(a, 3);
				codelength_sizes[stbi__compute_huffman_codes_length_dezigzag[i]] = (byte)s;
			}

			if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19))
				return false;
			n = 0;
			while (n < ntot)
			{
				var c = stbi__zhuffman_decode(a, &z_codelength);
				if (c < 0 || c >= 19)
					return false;
				if (c < 16)
				{
					lencodes[n++] = (byte)c;
				}
				else
				{
					byte fill = 0;
					if (c == 16)
					{
						c = (int)(stbi__zreceive(a, 2) + 3);
						if (n == 0)
							return false;
						fill = lencodes[n - 1];
					}
					else if (c == 17)
					{
						c = (int)(stbi__zreceive(a, 3) + 3);
					}
					else if (c == 18)
					{
						c = (int)(stbi__zreceive(a, 7) + 11);
					}
					else
					{
						return false;
					}

					if (ntot - n < c)
						return false;
					CRuntime.memset(lencodes + n, fill, (ulong)c);
					n += c;
				}
			}

			if (n != ntot)
				return false;
			if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit))
				return false;
			if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist))
				return false;
			return true;
		}

		public static bool stbi__parse_uncompressed_block(stbi__zbuf* a)
		{
			var header = stackalloc byte[4];
			var len = 0;
			var nlen = 0;
			var k = 0;
			if ((a->num_bits & 7) != 0)
				stbi__zreceive(a, a->num_bits & 7);
			k = 0;
			while (a->num_bits > 0)
			{
				header[k++] = (byte)(a->code_buffer & 255);
				a->code_buffer >>= 8;
				a->num_bits -= 8;
			}

			if (a->num_bits < 0)
				return false;
			while (k < 4)
				header[k++] = stbi__zget8(a);

			len = header[1] * 256 + header[0];
			nlen = header[3] * 256 + header[2];
			if (nlen != (len ^ 0xffff))
				return false;
			if (a->zbuffer + len > a->zbuffer_end)
				return false;
			if (a->zout + len > a->zout_end)
				if (!stbi__zexpand(a, a->zout, len))
					return false;
			CRuntime.memcpy(a->zout, a->zbuffer, (ulong)len);
			a->zbuffer += len;
			a->zout += len;
			return true;
		}

		public static bool stbi__parse_zlib_header(stbi__zbuf* a)
		{
			int cmf = stbi__zget8(a);
			var cm = cmf & 15;
			int flg = stbi__zget8(a);
			if (stbi__zeof(a) != 0)
				return false;
			if ((cmf * 256 + flg) % 31 != 0)
				return false;
			if ((flg & 32) != 0)
				return false;
			if (cm != 8)
				return false;
			return true;
		}

		public static bool stbi__parse_zlib(stbi__zbuf* a, int parse_header)
		{
			var final = 0;
			var type = 0;
			if (parse_header != 0)
				if (!stbi__parse_zlib_header(a))
					return false;
			a->num_bits = 0;
			a->code_buffer = 0;
			a->hit_zeof_once = 0;
			do
			{
				final = (int)stbi__zreceive(a, 1);
				type = (int)stbi__zreceive(a, 2);
				if (type == 0)
				{
					if (!stbi__parse_uncompressed_block(a))
						return false;
				}
				else if (type == 3)
				{
					return false;
				}
				else
				{
					if (type == 1)
					{
						fixed (byte* b = stbi__zdefault_length)
						{
							if (!stbi__zbuild_huffman(&a->z_length, b, 288))
								return false;
						}

						fixed (byte* b = stbi__zdefault_distance)
						{
							if (!stbi__zbuild_huffman(&a->z_distance, b, 32))
								return false;
						}
					}
					else
					{
						if (!stbi__compute_huffman_codes(a))
							return false;
					}

					if (!stbi__parse_huffman_block(a))
						return false;
				}
			} while (final == 0);

			return true;
		}

		public static bool stbi__do_zlib(stbi__zbuf* a, FixedArray<sbyte>* obuf, int olen, int exp, int parse_header)
		{
			a->zout_start = obuf;
			a->zout = obuf->Ptr;
			a->zout_end = obuf->Ptr + olen;
			a->z_expandable = exp;
			return stbi__parse_zlib(a, parse_header);
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct stbi__zbuf
		{
			public byte* zbuffer;
			public byte* zbuffer_end;
			public int num_bits;
			public int hit_zeof_once;
			public uint code_buffer;
			public sbyte* zout;
			public FixedArray<sbyte>* zout_start;
			public sbyte* zout_end;
			public int z_expandable;
			public stbi__zhuffman z_length;
			public stbi__zhuffman z_distance;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct stbi__zhuffman
		{
			public fixed ushort fast[512];
			public fixed ushort firstcode[16];
			public fixed int maxcode[17];
			public fixed ushort firstsymbol[16];
			public fixed byte size[288];
			public fixed ushort value[288];
		}
	}
}